# 设计模式

> SOLID原则，分别代表如下原则：
>
> - 单一功能原则
> - 开闭原则
> - 里氏替换原则
> - 接口隔离原则
> - 依赖反转原则

## 1.设计模式的分类

- 创建型；使用一些方式来创建一些对象，增加了代码的灵活性和可复用性。
- 组合型；使用一些方法来组装对象，从而形成一个比较复杂的对象，并保持结构的灵活和高效。
- 行为模式；负责对象间的高效沟通和指责委派。

## 2.从代码上如何判断哪些是面向对象，哪些是面向过程

面向对象和面向过程都是编程的一个范式而已。

### 2.1滥用get、set方法

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

> 既然itemsCount和totalPrice都定义了set方法，那么也意味着，任何人都可以修改这两个值的内容。从而让金额和数量和items的数量对应不上。
>
> items的虽然只提供了一个get方法，但是由于该方法返回的是一个list的对象，我们依然可以对这个集合进行修改，或者内部的对象进行修改。
>
> > **这里的代码违反了面对对象的封装性。**

## 3.抽象类和接口的区别

抽象类更多的是解决代码复用的问题，而接口则更加的偏重于解耦。

从类的关系上来看，抽象类是一种**自下而上**的设计思路，也就是说发现有些代码可以被重新复用的时候，可以使用抽象出来一个抽象类。

而接口则是从上而下的一种情况，这个一般是在编程的时候就开始设计接口，然后再通过对接口的实现来实现具体功能。

## 4.基于贫血模式的MVC架构违背OOP吗？

> 确实是违背了OOP的开发模式。

贫血模式

> 贫血模式就是类中只包含了数据，但是并没有包含逻辑相关的代码。

DDD开发类似于敏捷开发之类的概念，不要把他们想的太高大上。更重要的是，你需要深刻的了解业务，只有你深刻的了解业务之后，你才能使用DDD开发。如果你只是熟悉DDD开发概念，而不熟悉业务场景，那么DDD对你来说并没有太多的作用。

## 5.创建型

> 创建型的设计模式主要解决的是对象是如何创建的。

### 5.1单例模式

关于单例模式有如下的几个疑问

> 1. 为什么要使用单例？
> 2. 单例存在哪些问题？
> 3. 单例和静态类之间的区别是什么？
> 4. 有何替代方案？

#### 为什么要使用单例？

这里举一个例子，比如一个日志类，向同一个文件内写入数据。

```java
public class Logger {
  private FileWriter writer;
  
  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    writer.write(message);
  }
}

// Logger类的应用示例：
public class UserController {
  private Logger logger = new Logger();
  
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    logger.log(username + " logined!");
  }
}

public class OrderController {
  private Logger logger = new Logger();
  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    logger.log("Created an order: " + order.toString());
  }
}
```

文件中的内容会被覆盖。

> 1. 创建的时候是创建了两个logger对象，而这两个动作可能是多线程的。
> 2. 在向文件中追加内容的时候，会产生覆盖的效果。

![](./image/单例模式/文件追加.png)

而如果你想加锁，代码如下：

```java
public void log(String message) { 
  synchronized(this) { 
    writer.write(mesasge); 
  } 
}
```

其实作用是不大的，因为这个是对象所，而logger可以创建多个对象。他们是无能无力的。所以必须改为类锁

```java
public class Logger {
  private FileWriter writer;

  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    synchronized(Logger.class) { // 类级别的锁
      writer.write(mesasge);
    }
  }
}
```

鉴于FileWriter是一个对象级别的安全实例，其实自己可以创建一个Logger的单例，并且初始化一个FileWriter对象即可。

```java
public class Logger {
  private FileWriter writer;
  private static final Logger instance = new Logger();

  private Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public static Logger getInstance() {
    return instance;
  }
  
  public void log(String message) {
    writer.write(mesasge);
  }
}

// Logger类的应用示例：
public class UserController {
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log(username + " logined!");
  }
}

public class OrderController {  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log("Created a order: " + order.toString());
  }
}
```

还有一些场景需要使用到单例模式，比如计数器，配置信息等。

### 如何创建一个单例？

- 将构造方法private化，这样就避免了通过new来创建对象。
- 考虑对象创建的时候是否有线程安全问题
- 是否支持延迟加载
- 考虑getInstance()时候的性能是否足够高

饿汉式

```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance = new IdGenerator();
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

因为IdGenerator是静态的实例，所以在类加载的时候就已经初始化好了。这个时候不用担心是否会出现多线程安全问题。缺点是不支持懒加载。

> 有人说这样会过度占用资源，并且还会加长初始化的时间。这样的说法我是不认同的，因为如果用到你都会加载到内存中，如果不用到你干嘛写代码中。
>
> 而如果一个类的加载时间比较长，那么还放到懒加载里面就是不合理的，因为这样会降低系统性能，还不如放到初始化的时候来做。
>
> 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复

懒汉式

```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;
  private IdGenerator() {}
  public static synchronized IdGenerator getInstance() {
    if (instance == null) {
      instance = new IdGenerator();
    }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

双重检验

```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    if (instance == null) {
      synchronized(IdGenerator.class) { // 此处为类级别的锁
        if (instance == null) {// 这里为何要再加一个Null判断？ 
          //因为可能是多线程导致已经创建好了instance，如果直接创建会有问题。所以必须重写判断下
          //并且由于使用了synchronized，肯定会拿到instance是否真的被创建出来了
          instance = new IdGenerator();
        }
      }
    }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

```
实际上，上述实现方式存在问题：CPU 指令重排序可能导致在 IdGenerator 类的对象被关键字 new 创建并赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。这样，另一个线程就使用了一个没有完整初始化的 IdGenerator 类的对象。要解决这个问题，我们只需要给 instance 成员变量添加 volatile 关键字来禁止指令重排序即可。
```

静态内部类

这个方式既可以实现线程安全，又可以实现懒加载

```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private IdGenerator() {}

  private static class SingletonHolder{
    private static final IdGenerator instance = new IdGenerator();
  }
  
  public static IdGenerator getInstance() {
    return SingletonHolder.instance;
  }
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 原型模式

> 如果一个对象的创建成本比较大，而同一个类之间的差别又不大（大部分字段相同），这种情况下，我们可以利用已有的对象（原型）进行复制的方式来创建新对象，从而得到节约创建时间的目的。

深拷贝有两种方式

1. 一层层for循环，直到对象都是基本类型（包括string类型）。
2. 使用序列化和反序列化的方式

## 结构型

> 结构性模式主要解决的是对象如何进行组合或组装

### 代理模式

> 在不改变原始类的代码基础上，通过引入代理类给原始类添加附加功能。

适用范围都有哪些呢？

> 日志监控，流量监控，用户鉴权，全局异常处理等等。

静态代理的实现思路

> 实现和业务接口一样的实现类，但是内容是添加了前后逻辑的代码。并且嵌入了主体的逻辑代码。

```java
public class UserControllerProxy extends UserController {
  private MetricsCollector metricsCollector;

  public UserControllerProxy() {
    this.metricsCollector = new MetricsCollector();
  }

  public UserVo login(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    UserVo userVo = super.login(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }

  public UserVo register(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    UserVo userVo = super.register(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);

    return userVo;
  }
}
//UserControllerProxy使用举例
UserController userController = new UserControllerProxy();
```

动态代理

> 静态代理缺点就是需要设置N个模版，如果类太多，那么就需要设置很多类似模版的文件。导致大量的代码冗余。很可能这个代理只需要实现很少的代码而已。
>
> 而动态代理又分为两种：
>
> - java自带的动态代理（基于接口的）
> - CGLIB实现的动态代理（无需基于接口）

java自带的动态代理

> 其实实现方式和静态代理大同小异。无非可以总结为这几个顺序和步骤。
>
> 1. 创建需要被代理的类
> 2. 拿到被代理类的classLoader和interfaces
> 3. 创建被代理类
> 4. 调用Proxy.newProxyInstance，然后得到自己被代理的类
> 5. 开始执行想要执行的业务逻辑

业务逻辑类

```java
public interface UserService {
    void update();
}
```

```java
public class UserServiceImpl implements UserService{
    @Override
    public void update() {
        System.out.println("进行update操作....");
    }
}
```

代理类

```java
public class LogHandler implements InvocationHandler {
    Object target;  // 被代理的对象，实际的方法执行者

    public LogHandler(Object target) {
        this.target = target;
    }

    // 调用invoke方法之前执行
    private void before() {
        System.out.println(String.format("log start time [%s] ", new Date()));
    }
    // 调用invoke方法之后执行
    private void after() {
        System.out.println(String.format("log end time [%s] ", new Date()));
    }



    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);  // 调用 target 的 method 方法
        after();
        return result;  // 返回方法的执行结果
    }
}
```

调用代理类

```java
public class ProxyClient {
    public static void main(String[] args) {
        // 创建需要被代理的对象
        UserServiceImpl userService=new UserServiceImpl();
        // 得到被代理对象的classloader和接口
        ClassLoader classLoader = userService.getClass().getClassLoader();
        Class<?>[] interfaces = userService.getClass().getInterfaces();
        // 创建动态代理类
        InvocationHandler logHandler=new LogHandler(userService);
        /*
		   5.根据上面提供的信息，创建代理对象 在这个过程中，
               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码
               b.然后根据相应的字节码转换成对应的class，
               c.然后调用newInstance()创建代理实例
		 */
        UserService proxyUserService = (UserService)Proxy.newProxyInstance(classLoader, interfaces, logHandler);

        proxyUserService.update();
    }
}
```

基于CGLIB的动态代理

```java
// 第一个动态代理类
public class LogInterceptor1 implements MethodInterceptor {
    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object result = methodProxy.invokeSuper(object, objects);
        after();
        return result;
    }
    private void before() {
        System.out.println(String.format("log1 start time [%s] ", new Date()));
    }
    private void after() {
        System.out.println(String.format("log1 end time [%s] ", new Date()));
    }
}
```

```java
// 第二个动态代理类
public class LogInterceptor2 implements MethodInterceptor {
    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object result = methodProxy.invokeSuper(object, objects);
        after();
        return result;
    }
    private void before() {
        System.out.println(String.format("log2 start time [%s] ", new Date()));
    }
    private void after() {
        System.out.println(String.format("log2 end time [%s] ", new Date()));
    }
}
```

需要被代理的类

```java
public class UserDao {
    public void select() {
        System.out.println("UserDao 查询 selectById");
    }
    public void update() {
        System.out.println("UserDao 更新 update");
    }
}
```

过滤器

```java
// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。
public class DaoFilter implements CallbackFilter {
    @Override
    public int accept(Method method) {
        if ("select".equals(method.getName())) {
            return 1;   // 代表使用拦截器中的第一个
        }
        return 0;   // 代表使用拦截器列表的第二个
    }
}
```

测试方法

```java
public class CGLIBDemo {
    public static void main(String[] args) {
        LogInterceptor1 logInterceptor1 = new LogInterceptor1();
        LogInterceptor2 daoProxy = new LogInterceptor2();

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserDao.class);  // 设置超类，cglib是通过继承来实现的
        enhancer.setCallback(daoProxy);

        enhancer.setCallbacks(new Callback[]{ logInterceptor1,daoProxy, NoOp.INSTANCE});   // 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理
        enhancer.setCallbackFilter(new DaoFilter());


        UserDao dao = (UserDao)enhancer.create();   // 创建代理类
        dao.update();
        dao.select();
    }
}
```

JDK的动态代理和CGLIB的动态代理差异

jdk的动态代理

> 1. 实现InvocationHandler接口，然后重写invoke方法来完成代理的实现。
> 2. jdk的动态代理是使用了反射来实现的
> 3. jdk动态代理之所以**只能代理接口**是因为**代理类本身已经extends了Proxy，而java是不允许多重继承的**，但是允许实现多个接口
> 4. jdk的动态代理跟随着jdk走可以了。维护简单

CGLIB的动态代理

> 由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；
>
> CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
>
> 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
>
> 但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。
>
> 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。

### 桥接模式

> 抽象和实现解构，让他们可以独立变化。

```java
public enum NotificationEmergencyLevel {
  SEVERE, URGENCY, NORMAL, TRIVIAL
}

public class Notification {
  private List<String> emailAddresses;
  private List<String> telephones;
  private List<String> wechatIds;

  public Notification() {}

  public void setEmailAddress(List<String> emailAddress) {
    this.emailAddresses = emailAddress;
  }

  public void setTelephones(List<String> telephones) {
    this.telephones = telephones;
  }

  public void setWechatIds(List<String> wechatIds) {
    this.wechatIds = wechatIds;
  }

  public void notify(NotificationEmergencyLevel level, String message) {
    if (level.equals(NotificationEmergencyLevel.SEVERE)) {
      //...自动语音电话
    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {
      //...发微信
    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {
      //...发邮件
    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {
      //...发邮件
    }
  }
}

//在API监控告警的例子中，我们如下方式来使用Notification类：
public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }


  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

以上的代码可以进行优化

```java
public interface MsgSender {
  void send(String message);
}

public class TelephoneMsgSender implements MsgSender {
  private List<String> telephones;

  public TelephoneMsgSender(List<String> telephones) {
    this.telephones = telephones;
  }

  @Override
  public void send(String message) {
    //...
  }

}

public class EmailMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public class WechatMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public abstract class Notification {
  protected MsgSender msgSender;

  public Notification(MsgSender msgSender) {
    this.msgSender = msgSender;
  }

  public abstract void notify(String message);
}

public class SevereNotification extends Notification {
  public SevereNotification(MsgSender msgSender) {
    super(msgSender);
  }

  @Override
  public void notify(String message) {
    msgSender.send(message);
  }
}

public class UrgencyNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class NormalNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class TrivialNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
```

> 实际上就是把if里面逻辑，拆分成一个通知和发送的类别。然后推送和发送又产生了关系。
>
> 而通知又分为很多通知。

### 装饰器模式

> 利用继承的方式来实现一套，子类对父类的功能强增。而这个增加是和父类相关的逻辑。而带来是和要代理类完全无关的。

示例代码就是jdk的IO流。

BufferInputSteam实现的是一个缓冲流，但是它的父类是FilterInputSteam. 

```java
InputStream in = new FileInputStream("/user/wangzheng/test.txt");
InputStream bin = new BufferedInputStream(in);
byte[] data = new byte[128];
while (bin.read(data) != -1) {
  //...
}
```

上面的代码就是实现了装饰器模式

### 适配器模式

> 这个模式是用来做适配的，它将不兼容的接口转换为可兼容的接口。让原本不兼容的接口也能好好工作。
>
> > 通俗地理解就是以某一个接口为准，然后实现这个接口，然后这个接口中调用所谓不兼容的接口，从而来实现兼容。

适配器有两种实现方式

- 类适配器（通过继承的关系来实现）
- 对象适配器（通过使用组合的关系来实现）

类适配器和对象适配器

```java
// 类适配器: 基于继承
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }
  
  public void f2() {
    //...重新实现f2()...
  }
  
  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
}

// 对象适配器：基于组合
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor implements ITarget {
  private Adaptee adaptee;
  
  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }
  
  public void f1() {
    adaptee.fa(); //委托给Adaptee
  }
  
  public void f2() {
    //...重新实现f2()...
  }
  
  public void fc() {
    adaptee.fc();
  }
}
```

适配器的应用场景

> 适配器可以当做一个补偿的情况，就是解决当初设计不够严谨导致的不兼容问题。

封装有缺陷的接口设计

> 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。
>
> 说实话，这个上面的描述影响到`自身代码的可测性`我是没有怎么懂。

代码如下

```java
public class CD { //这个类来自外部sdk，我们无权修改它的代码
  //...
  public static void staticFunction1() { //... }
  
  public void uglyNamingFunction2() { //... }

  public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }
  
   public void lowPerformanceFunction4() { //... }
}

// 使用适配器模式进行重构
public interface ITarget {
  void function1();
  void function2();
  void fucntion3(ParamsWrapperDefinition paramsWrapper);
  void function4();
  //...
}
// 注意：适配器类的命名不一定非得末尾带Adaptor
public class CDAdaptor extends CD implements ITarget {
  //...
  public void function1() {
     super.staticFunction1();
  }
  
  public void function2() {
    super.uglyNamingFucntion2();
  }
  
  public void function3(ParamsWrapperDefinition paramsWrapper) {
     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);
  }
  
  public void function4() {
    //...reimplement it...
  }
}
```

统一多个类的接口设计

> 某个功能的实现依赖于多个外部系统。

假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。

```java
public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口
  //text是原始文本，函数输出用***替换敏感词之后的文本
  public String filterSexyWords(String text) {
    // ...
  }
  
  public String filterPoliticalWords(String text) {
    // ...
  } 
}

public class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口
  public String filter(String text) {
    //...
  }
}

public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口
  public String filter(String text, String mask) {
    //...
  }
}

// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好
public class RiskManagement {
  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();
  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();
  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();
  
  public String filterSensitiveWords(String text) {
    String maskedText = aFilter.filterSexyWords(text);
    maskedText = aFilter.filterPoliticalWords(maskedText);
    maskedText = bFilter.filter(maskedText);
    maskedText = cFilter.filter(maskedText, "***");
    return maskedText;
  }
}

// 使用适配器模式进行改造
public interface ISensitiveWordsFilter { // 统一接口定义
  String filter(String text);
}

public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {
  private ASensitiveWordsFilter aFilter;
  public String filter(String text) {
    String maskedText = aFilter.filterSexyWords(text);
    maskedText = aFilter.filterPoliticalWords(maskedText);
    return maskedText;
  }
}
//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...

// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，
// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。
public class RiskManagement { 
  private List<ISensitiveWordsFilter> filters = new ArrayList<>();
 
  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {
    filters.add(filter);
  }
  
  public String filterSensitiveWords(String text) {
    String maskedText = text;
    for (ISensitiveWordsFilter filter : filters) {
      maskedText = filter.filter(maskedText);
    }
    return maskedText;
  }
}
```

替换依赖的外部系统

> 个人感觉这个例子比较鸡肋，其实你开一个IB的接口实现，改动一行代码就可以了，也不用创建一个类。

```java
// 外部系统A
public interface IA {
  //...
  void fa();
}
public class A implements IA {
  //...
  public void fa() { //... }
}
// 在我们的项目中，外部系统A的使用示例
public class Demo {
  private IA a;
  public Demo(IA a) {
    this.a = a;
  }
  //...
}
Demo d = new Demo(new A());

// 将外部系统A替换成外部系统B
public class BAdaptor implemnts IA {
  private B b;
  public BAdaptor(B b) {
    this.b= b;
  }
  public void fa() {
    //...
    b.fb();
  }
}
// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，
// 只需要将BAdaptor如下注入到Demo即可。
Demo d = new Demo(new BAdaptor(new B()));
```

日志方面的使用

比如Slf4j这个框架就做了适配器。并且通过SPI技术来实现；

```java
// slf4j统一的接口定义
package org.slf4j;
public interface Logger {
  public boolean isTraceEnabled();
  public void trace(String msg);
  public void trace(String format, Object arg);
  public void trace(String format, Object arg1, Object arg2);
  public void trace(String format, Object[] argArray);
  public void trace(String msg, Throwable t);
 
  public boolean isDebugEnabled();
  public void debug(String msg);
  public void debug(String format, Object arg);
  public void debug(String format, Object arg1, Object arg2)
  public void debug(String format, Object[] argArray)
  public void debug(String msg, Throwable t);

  //...省略info、warn、error等一堆接口
}

// log4j日志框架的适配器
// Log4jLoggerAdapter实现了LocationAwareLogger接口，
// 其中LocationAwareLogger继承自Logger接口，
// 也就相当于Log4jLoggerAdapter实现了Logger接口。
package org.slf4j.impl;
public final class Log4jLoggerAdapter extends MarkerIgnoringBase
  implements LocationAwareLogger, Serializable {
  final transient org.apache.log4j.Logger logger; // log4j
 
  public boolean isDebugEnabled() {
    return logger.isDebugEnabled();
  }
 
  public void debug(String msg) {
    logger.log(FQCN, Level.DEBUG, msg, null);
  }
 
  public void debug(String format, Object arg) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.format(format, arg);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String format, Object arg1, Object arg2) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String format, Object[] argArray) {
    if (logger.isDebugEnabled()) {
      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
    }
  }
 
  public void debug(String msg, Throwable t) {
    logger.log(FQCN, Level.DEBUG, msg, t);
  }
  //...省略一堆接口的实现...
}
```

几个模式的特点

- 代理模式主要是对原型类不做改变，而做的增强
- 桥接模式主要是吧实现分割开来，从而实现解构
- 装饰器模式其实就是对原来的功能进行加强
- 配置器模式就是对原来的接口进行适配

### 门面模式

> 门面模式给子系统给一组子接口提供了一个统一的接口；门面模式是一个高级别的接口，它可以让子系统更容易使用。

比如现在有a,b,c三个接口供前端网页进行调用，但是经过测试发现三个接口浪费在网络上的时间比较多，那么就可以抽出来一个接口x，这个接口来封装a,b,c这三个接口。从而减少网络传输的时间。

也可以使用门面模式来实现分布式事务。比如a,b两个业务是两个接口，那么可以把他们柔和到一个接口中，这样从而变相的让分布式事务生效。

### 组合模式

> 这里的组合模式和面向对象中的对象组合没有任何关系。
>
> 这里讲的"组合模式"主要是用来处理树形结构的。也就是应用的场景必须是树形的结构。

### 享元模式

> 享元，顾名思义就是被共享的单元。享元模式的意图是复用对象，节约内存，前提是享元对象是**不变的对象。**
>
> 因为对象要进行共享，所以这样的方式可以节约内存空间，并且还不能修改共享的对象，因为如果修改了对象，那么这个其他地方使用的对象也会发生改变。

象棋中的例子

> 当你设计一个象棋游戏的时候，如果有N个房间都在玩游戏。这个时候创建的象棋的对象将会很多，这个时候就可以使用享元模式来做。
>
> 因为象棋的数量和颜色是固定的，所以可以把这些对象做成一个公共对象，为象棋唯一不同的就是它所处的位置。
>
> 所以创建两个对象：象棋子对象+一个位置的对象（这个里面包含象棋对象）

```java
// 享元类
public class ChessPieceUnit {
  private int id;
  private String text;
  private Color color;

  public ChessPieceUnit(int id, String text, Color color) {
    this.id = id;
    this.text = text;
    this.color = color;
  }

  public static enum Color {
    RED, BLACK
  }

  // ...省略其他属性和getter方法...
}

public class ChessPieceUnitFactory {
  private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>();

  static {
    pieces.put(1, new ChessPieceUnit(1, "車", ChessPieceUnit.Color.BLACK));
    pieces.put(2, new ChessPieceUnit(2,"馬", ChessPieceUnit.Color.BLACK));
    //...省略摆放其他棋子的代码...
  }

  public static ChessPieceUnit getChessPiece(int chessPieceId) {
    return pieces.get(chessPieceId);
  }
}

public class ChessPiece {
  private ChessPieceUnit chessPieceUnit;
  private int positionX;
  private int positionY;

  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {
    this.chessPieceUnit = unit;
    this.positionX = positionX;
    this.positionY = positionY;
  }
  // 省略getter、setter方法
}

public class ChessBoard {
  private Map<Integer, ChessPiece> chessPieces = new HashMap<>();

  public ChessBoard() {
    init();
  }

  private void init() {
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(1), 0,0));
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(2), 1,0));
    //...省略摆放其他棋子的代码...
  }

  public void move(int chessPieceId, int toPositionX, int toPositionY) {
    //...省略...
  }
}
```

编辑器的例子

> 这个例子中可以把字体的颜色等信息给抽出来做成共享的对象。
>
> > 其实享元模式，就是把公共的信息抽出来，然后进行共用，从而合理利用空间。

```java
public class CharacterStyle {
  private Font font;
  private int size;
  private int colorRGB;

  public CharacterStyle(Font font, int size, int colorRGB) {
    this.font = font;
    this.size = size;
    this.colorRGB = colorRGB;
  }

  @Override
  public boolean equals(Object o) {
    CharacterStyle otherStyle = (CharacterStyle) o;
    return font.equals(otherStyle.font)
            && size == otherStyle.size
            && colorRGB == otherStyle.colorRGB;
  }
}

public class CharacterStyleFactory {
  private static final List<CharacterStyle> styles = new ArrayList<>();

  public static CharacterStyle getStyle(Font font, int size, int colorRGB) {
    CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);
    for (CharacterStyle style : styles) {
      if (style.equals(newStyle)) {
        return style;
      }
    }
    styles.add(newStyle);
    return newStyle;
  }
}

public class Character {
  private char c;
  private CharacterStyle style;

  public Character(char c, CharacterStyle style) {
    this.c = c;
    this.style = style;
  }
}

public class Editor {
  private List<Character> chars = new ArrayList<>();

  public void appendCharacter(char c, Font font, int size, int colorRGB) {
    Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));
    chars.add(character);
  }
}
```

享元模式和缓存，线程池区别

> 缓存主要关键点在于存。
>
> 线程池等池技术是为了多次服用而节约时间，因为这样不用每次都创建新对象了。而共享的对象其实就是让公共对象都可以使用。
>
> 对象其实就死共享的单元。

#### 享元模式在Integer和String中的使用

Integer能够根据数据来判断是自动装箱还是自动拆箱。比如Integer i=56;实际上是Integer i=Integer.valueOf(56);

会对数据进行装箱。

```java
Integer i1 = 56;
Integer i2 = 56;
Integer i3 = 129;
Integer i4 = 129;
System.out.println(i1 == i2);
System.out.println(i3 == i4);
```

而上面的答案是true和false，这样造成的结果原因就是Integer会把-128~127的数据给缓存起来。当在这个范围之内的时候使用的是同一个对象，当超过的时候是使用的新创建的对象。

```java
String s1 = "小争哥";
String s2 = "小争哥";
String s3 = new String("小争哥");

System.out.println(s1 == s2);
System.out.println(s1 == s3);
```

## 行为型

> 行为模式主要解决的是类和对象如何交互的问题。

### 观察者模式

> 观察者模式(observe design pattern)也被称为发布订阅模式(Publish-subscribe Design Parttern)
>
> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

#### 最常见的观察者模式

```java
public interface Subject {
  void registerObserver(Observer observer);
  void removeObserver(Observer observer);
  void notifyObservers(Message message);
}

public interface Observer {
  void update(Message message);
}

public class ConcreteSubject implements Subject {
  private List<Observer> observers = new ArrayList<Observer>();

  @Override
  public void registerObserver(Observer observer) {
    observers.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    observers.remove(observer);
  }

  @Override
  public void notifyObservers(Message message) {
    for (Observer observer : observers) {
      observer.update(message);
    }
  }

}

public class ConcreteObserverOne implements Observer {
  @Override
  public void update(Message message) {
    //TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverOne is notified.");
  }
}

public class ConcreteObserverTwo implements Observer {
  @Override
  public void update(Message message) {
    //TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverTwo is notified.");
  }
}

public class Demo {
  public static void main(String[] args) {
    ConcreteSubject subject = new ConcreteSubject();
    subject.registerObserver(new ConcreteObserverOne());
    subject.registerObserver(new ConcreteObserverTwo());
    subject.notifyObservers(new Message());
  }
}
```

> 观察者其实就是被改动的对象；其实就是使用一个类来触发所有观察者的某个动作。

#### 实例1

现在有一个p2p的系统，每当用户注册成功以后那么就给该用户发放一些代金券或者奖励金。然后的代码如下：

```java
public class UserController {
  private UserService userService; // 依赖注入
  private PromotionService promotionService; // 依赖注入

  public Long register(String telephone, String password) {
    //省略输入参数的校验代码
    //省略userService.register()异常的try-catch代码
    long userId = userService.register(telephone, password);
    promotionService.issueNewUserExperienceCash(userId);
    return userId;
  }
}
```

如果只是发放一些奖励金那么以上的代码是没有什么问题的，但是如果业务后续发生变动，比如是发优惠卷，并且还要给用户发放一封"注册成功"的短信之类的。那么是需要修改这个register这个类中的代码的。这个时候就违背了`开闭原则`；

所以这个时候可以使用观察者模式，其实就是发优惠劵和发送短信集成观察者的interface。

```java
public interface RegObserver {
  void handleRegSuccess(long userId);
}

public class RegPromotionObserver implements RegObserver {
  private PromotionService promotionService; // 依赖注入

  @Override
  public void handleRegSuccess(long userId) {
    promotionService.issueNewUserExperienceCash(userId);
  }
}

public class RegNotificationObserver implements RegObserver {
  private NotificationService notificationService;

  @Override
  public void handleRegSuccess(long userId) {
    notificationService.sendInboxMessage(userId, "Welcome...");
  }
}

public class UserController {
  private UserService userService; // 依赖注入
  private List<RegObserver> regObservers = new ArrayList<>();

  // 一次性设置好，之后也不可能动态的修改
  public void setRegObservers(List<RegObserver> observers) {
    regObservers.addAll(observers);
  }

  public Long register(String telephone, String password) {
    //省略输入参数的校验代码
    //省略userService.register()异常的try-catch代码
    long userId = userService.register(telephone, password);

    for (RegObserver observer : regObservers) {
      observer.handleRegSuccess(userId);
    }

    return userId;
  }
}
```

### 模版模式

> 模版模式的主要作用是为了复用

> Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.

模版的代码样例

```java
public abstract class AbstractClass {
  public final void templateMethod() {
    //...
    method1();
    //...
    method2();
    //...
  }
  
  protected abstract void method1();
  protected abstract void method2();
}

public class ConcreteClass1 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

public class ConcreteClass2 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

AbstractClass demo = ConcreteClass1();
demo.templateMethod();
```

上面代码需要注意的是:

> templateMethod 方法是被final修饰的，这样意味着不能去重新模版，从而保证了模版模式正常运行。

#### 复用

java中的流相关复用的代码

```java
public abstract class InputStream implements Closeable {
  //...省略其他代码...
  
  public int read(byte b[], int off, int len) throws IOException {
    if (b == null) {
      throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
      throw new IndexOutOfBoundsException();
    } else if (len == 0) {
      return 0;
    }

    int c = read();
    if (c == -1) {
      return -1;
    }
    b[off] = (byte)c;

    int i = 1;
    try {
      for (; i < len ; i++) {
        c = read();
        if (c == -1) {
          break;
        }
        b[off + i] = (byte)c;
      }
    } catch (IOException ee) {
    }
    return i;
  }
  
  public abstract int read() throws IOException;
}

public class ByteArrayInputStream extends InputStream {
  //...省略其他代码...
  
  @Override
  public synchronized int read() {
    return (pos < count) ? (buf[pos++] & 0xff) : -1;
  }
}
```

> read(byte b[], int off, int len) 这个方法就相当于一个模版的方法，它复用了下面int read()方法

Java AbstractList

```java
public boolean addAll(int index, Collection<? extends E> c) {
    rangeCheckForAdd(index);
    boolean modified = false;
    for (E e : c) {
        add(index++, e);
        modified = true;
    }
    return modified;
}

public void add(int index, E element) {
    throw new UnsupportedOperationException();
}
```

> addAll也可以看做是一个模版的方法，复用了add方法，而add方法必须重新，否则就会抛出异常。

## 策略模式

> Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

解耦的是哪一部分呢？

> 工程模式结构的对象是创建和使用，观察者模式结构的是观察者和被观察者。而策略模式解耦的是定义，创建和使用这三部分。

**使用策略模式来避免分支判断**

没有使用策略模式的时候

```java
public class OrderService {
  public double discount(Order order) {
    double discount = 0.0;
    OrderType type = order.getType();
    if (type.equals(OrderType.NORMAL)) { // 普通订单
      //...省略折扣计算算法代码
    } else if (type.equals(OrderType.GROUPON)) { // 团购订单
      //...省略折扣计算算法代码
    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单
      //...省略折扣计算算法代码
    }
    return discount;
  }
}
```

使用策略模式的情况下

```java
// 策略的定义
public interface DiscountStrategy {
  double calDiscount(Order order);
}
// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...

// 策略的创建
public class DiscountStrategyFactory {
  private static final Map<OrderType, DiscountStrategy> strategies = new HashMap<>();

  static {
    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());
    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());
    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());
  }

  public static DiscountStrategy getDiscountStrategy(OrderType type) {
    return strategies.get(type);
  }
}

// 策略的使用
public class OrderService {
  public double discount(Order order) {
    OrderType type = order.getType();
    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);
    return discountStrategy.calDiscount(order);
  }
}
```

> 实际上就是创建的时候使用map来进行缓存起来；
>
> 每种策略都实现策略的接口，然后通过变量来找到对应的策略对象，然后执行逻辑。

如果想每次都创建一个策略对象，那么需要使用以下的代码

```java
public class DiscountStrategyFactory {
  public static DiscountStrategy getDiscountStrategy(OrderType type) {
    if (type == null) {
      throw new IllegalArgumentException("Type should not be null.");
    }
    if (type.equals(OrderType.NORMAL)) {
      return new NormalDiscountStrategy();
    } else if (type.equals(OrderType.GROUPON)) {
      return new GrouponDiscountStrategy();
    } else if (type.equals(OrderType.PROMOTION)) {
      return new PromotionDiscountStrategy();
    }
    return null;
  }
}
```

> 但是上面的问题是：其实只是把创建对象的过程放到了工厂类中，其实并没有真正的让if-else消失。
>
> 下面来说下来使用策略模式来让if-else真正的消失。
