## java程序发生了死锁怎么办

使用jstack的工具来查看dump文件，然后查看是否有deadlock等字样，然后根据日志来找到相对应的代码。

解决方案

> 可以使用ReentrantLock中的tryLock或者tryLock添加上时间来进行获取锁，如果获取锁失败则直接报错。从而避免发生死锁。

## 频繁的Full GC问题排查

根据JVM中的对象区域分配策略，有几种种情况对象可以直接进入到老年代。

第一种情况：当Eden区域满了的时候，然后进行minor gc进行回收以后，新的对象依然不能够放到到年轻代，这个时候老年代要进行内存共担的要求，会直接尝试把对象放入到老年代。 如果老年代这个时候没有连续的空间，会触发Full GC.

第二种情况：

当对象的大小大于了设定值，会直接进入到老年代，这会导致很多朝生夕死的对象都进入到老年代，从而导致频繁触发Full GC。

第三种情况：

由于内存泄漏导致大量的对象进入到老年代，从而导致老年代频繁Full GC,最后导致OOM。

## CPU飙高

死循环，比如while循环然后去一个mysql中的数据进行修改状态，但是逻辑发生了异常，这个数据的状态没有修改，还是待处理的状态，然后while循环还在一直进行处理，从而造成这个数据一直在循环处理。

频繁的垃圾回收，比如原来朝生夕死的对象都放到年老代，从而导致频繁的Full GC进行回收，从而造成cpu飙高。

解决频繁回收的问题：调整对象的大小；调整年轻代和老年代的比例，从而让朝生夕死的对象进入到年轻代，而不是直接进入到老年代。

## Mysql中死锁问题的排查

其实就是两个事务，分别持有对方的锁，并且还等待对方的释放锁而造成的问题。

解决方案

1. 调整获取锁的顺序
2. 使用乐观锁，也就是在原有条件的情况下，添加上版本号来进行更新

## Mysql数据库连接池爆满如何排除

连接池总结

```
https://archmanual.com/backend/dbpool/
```

## 线上系统接口响应很慢

确认范围：是某个用户还是所有用户。是某个环境还是所有环境问题。

如果是单个用户的话，可以根据这个用户的请求拼接数据来进行排查，一般是程序写的有问题，比如查询的时候使用的是for循环查询，组装数据的时候使用的sql是一个慢sql等。

如果是所有用户问题，那么就需要检查该环境配置，比如cpu是否飙高，内存剩余是否足够等等。

如果是环境问题，可能是随着业务量的增加环境配置差，比如mysq测试环境的数据是从生产同步过来的，会导致查询和插入很慢，这是因为测试环境的mysql机器性能差。

还可以使用arthas这类工具，来快速排查速度慢在哪里。排查出来可能是第三方系统的速度慢等等。

## OOM一定会导致java程序退出吗

OOM也是异常的一种，只不过是Error异常。这个异常如果是在主线程中的并且还是没有进行异常捕获的，那么就会导致JVM退出。

如果是在子线程中的，那么不进行捕获也不会导致主线程异常，这个时候也不会导致JVM退出。只有主线程中的OOM没有捕获才会导致JVM退出。

## 对象一定会分配到堆上面吗

根据逃逸分析，如果对象没有逃逸出方法，那么这些对象就有可能被分配到栈上，这样做的目的就是因为这些对象是朝生夕死的，所以随着出栈这些对象就会很快被回收掉，从而节约对内存，还有个好处就是可以直接访问对象，加快访问速度。

## 内存泄露和内存溢出的区别

内存泄露

是指一些对象已经不需要被使用了，但是还是被引用着，从而导致这些对象不能够被垃圾回收，从而导致内存空间不足而导致OOM。

内存泄露是通常是由于代码问题而导致对象没有进行正常回收。

内存溢出

通常指正常程序运行的情况下，产生的对象无法被分配到JVM内存中从而造成的异常。

## JVM分配内存如何保证线程安全

TLAB（Thread Local Allocation Buffer）

是线程私有的内存区域，线程可以在这个块中直接分配对象，而不需要共享堆进行同步。

如果TLAB内存空间不足的时候，这个线程可以再申请一个新的TLAB或者共享堆分配。

CAS

通过cas的方式来让某个线程获取到分配内存的指针，从而来避免加锁而造成了内存分配现场不安全。

## JVM的内存是线程共享的吗？

JVM内存空间通常是可以被线程共享的，但是并不意味着JVM中的对象和数据都会被被多个线程来进行操作。

TLAB，是给每个线程分配一块内存区域，从而让每个线程可以分配内存

栈上分配，通过把对象分配到栈上从而使对象属于这个私有线程。

还有对象和数组的引用都是分配在栈上，如果这些引用是私有的，那么对应的对象也是不会被其他线程访问到的。

## Class常量池和运行时常量池的区别

Class常量池包含了类和接口一些信息。存储在.class文件中，在编译的时候已经确定。

运行时常量池：class文件被加载到JVM的一种表现形式，实际上是类加载的过程。通常被保存在元空间内。

```
https://cloud.tencent.com/developer/article/1450501
```

## JVM内存为什么要分代

1. 提高垃圾回收的效率。
2. 减少GC的停顿时间。大部分对象都是朝生夕死的，所以能够快速把年轻代的对象给回收掉，从而减少停顿。
3. 优化内存分配。能够减少内存碎片的产生。
4. 简化内存管理。不同的区域使用不同的垃圾回收器。
5. 适用于实际场景。大部分对象都符合分代的假设。

## GC是任意时候都可以进行的吗

GC垃圾收集器只能在**安全点**才能进行。

安全点解释

安全点的目的并不是为了让线程停止下来，它的目的是让线程得到一个相对稳定的执行状态，这个时候就可以进行垃圾回收了。通常在方法调用，跳出循环，异常跳转的位置指令会产生安全点。

如果设置安全点

主动式中断，其实就是设置一个标志位，这个标志位和安全点是一样的，然后线程进行轮询来看看自己是否得到了安全点。

```
https://juejin.cn/post/6994799204522541070
```

## 为何垃圾回收要Stop The World

1. 内存的一致性和安全性；因为程序在运行的过程中会修改引用的，这会导致垃圾回收获取到的数据和实际情况不一致，从而导致程序崩溃。
2. 简化垃圾回收算法和提高效率。因为stop the wolrd所以可以高效的进行回收垃圾，不用考虑引用的改变等。

安全性举例

```java
public class A {

 public static Person person=new Person();
 
 public void test(){
 	Person temp=null;
 	temp=person;
 	person=null;
 	
 	System.out.println(temp);
 }
}
// 垃圾回收线程发现person这个引用已经变成了null，于是就判断对象Person没有被应用了，所以会被Person进行回收。
// 这个多线程情况下由于数据不同步是有可能的。
```

## ThreadLocal

chttps://www.cnblogs.com/jtea/p/17595983.html
