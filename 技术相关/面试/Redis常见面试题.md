## 常见面试题

使用链接看下



## 连续签到

可以使用bitmap的形式来进行存储（只要是0,1形式的方式都可以使用bitmap来进行存储）。这里有两种方案：

方案1：

每天的日期作为key，然后后面的bitmap的每个位上都是相对应的一个用户的是否登录。如果是这样的一个思路的话，那么统计30天的数据，需要有30个以日期为key的bitmap。

这种方式使用用户量超级大的统计。统计当天的信息的时候是非常方便的，但是统计某一个用户的连续登录稍微麻烦那么一丢丢，因为需要去每个日期中遍历。

方案2：

以每个用户的唯一ID作为key，然后bitmap是存储30天是否签到的数据。这种方式是用户量比较少的情况下；

这个方式统计单个用户的时候非常方便，但是如果是统计当天所有用户则成本比较高，特别是用户特别多的时候。

## 给你一亿rediskey如何找到共同好友

既然都有一个亿数据，那么就不建议都放到redis里面进行存储。可以使用离线的方式，比如使用mysql存储，然后使用定时任务来执行。或者使用neo4j的形式来。

## 如何防止重复下单

根据用户账号+商品的编号作为一个key，来进行防止重复下单。

## 设计一个秒杀系统

https://github.com/resumejob/How-to-design-a-spike-system

## BITMAP的使用

```
https://juejin.cn/post/6998348240441573412
```

## Redis 6为何引入了多线程

Redis 6引入了多线程主要是处理网络IO这块的操作，至于命令行的操作还是使用的单线程来进行处理的。

请求量比较大的时候需要IO操作，其中包括网络的连接和内容的解析等。如果使用多线程可以提高出来效率，这样充分的利用好了多CPU的能力。

## Redis如何来解决热key问题

1. 使用本地的缓存来进行解决。这样的方式是提前可以预知到一些热key的存在，比如秒杀的时候等。
2. 把一个key分成多个子key，然后分布到不同的节点，从而减低redis热key带来的消耗。
3. 进行限流
4. 对于不可控制的热key，可以在代码中写好配置逻辑，当某些情况出现的时候，可以通过sdk预加热本地缓存，然后走本地缓存来减少redis的压力。

## Redis大key问题如何解决

使用` Rdbtools` 来进行查到到大key。一般value值超过10k则认为是大key。

大key通常指的是某个key后面的value值很大，从而导致redis的网络阻塞，redis内存不足等等问题。

把一个大的value值拆分成多个小值。比如list中的元素特别多，然后把list中的元素给拆分成多个。

map的元素特别的多，给拆分多多个小的map

## 缓冲垫和数据库双写不一致问题如何解决

双写不一致的情况的发生原因是这样发生的：有两个线程，一个线程查询，如果没有就查询放入到redis中；

一个线程是更新mysql的时候，然后同时更新redis缓存。

这个时候由于时序性的不同会造成线程1更新的时间晚，而覆盖了线程2更新的值，从而造成数据的不一致问题。

解决方案1

通过msyql的binlog的方式，然后通过canal来进行监控，然后更新redis，从而让redis实现最终一致性。

解决方案2

使用分布式锁来实现，但是缺点就是效率低下。

解决方案3

根据业务每次更新或者插入的时候都向redis中插入或者更新数据，这样造成只有一个地方更新数据，从而不会出现双写问题。

## Redis种的key过期了一定会立即被删除吗

redis中的值并不是已过期就删除的。Redis是采用了一种惰性删除和定期删除相结合的方式来进行删除过期键。

惰性删除

当客户端访问一个键的时，如果判断这个键已经过期，那么就把这个值给删除。如果客户端一直没有访问，那么则不会进行删除

定时删除

redis会周期性的抽取一部分设置了过期键的值进行检查，如果过期就进行删除。

