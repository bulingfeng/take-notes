# 准备工作

- elementUI
- axios-用来调用接口



思考

前端的学习最重要也是最基础的莫过于 增删改查，所以先从这几个点入手



# 前端的学习

## setup函数

作用就是页面刚开始加载的时候启动的函数，咋这个里面直接写相对于的变量和函数即可

## reactive()和ref()函数

reactive()函数是传入一个对象数据，然后返回一个响应式对象。

ref()函数可以传入一个简单的值或者一个对象数据，然后返回一个响应式对象。通过函数调用修改里面的普通对象的时候，需要使用.value来获取到数值。

reactive函数使用指南

> 1. import {reactive} from 'vue'
> 2. reactive(对象类型数据)

## computed

计算函数

```vue
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

因为使用的是**publishedBooksMessage**而不是函数**publishedBooksMessage()**,这个属性其实是使用的缓存，而不是方法。方法是每次调用都会重新计算一遍，而属性是只有数据变更才会发生变化。

## watch函数

监听一个或者多个数据的变化，当数据变化的时候然后触发某些动作（回调函数）。

2个额外参数immediate立即执行,deep深度监听

watch函数默认是一个浅监听，比如ref()函数里面传入了对象，然后修改内部对象的值，那么这个是不会监听到数据的变化，这个时候就需要设置deep=true

## 生命周期函数

使用方式

> 1. 导入生命周期函数
> 2. 使用生命周期函数

## 父传子通讯

基本思想

1. 父组件中给子组件绑定属性
2. 子组件内部通过props选项接收

## 子传父通讯

基本思想

1. 父组件通过给子组件通过@绑定事件
2. 子组件内部通过$emit方法触发事件

## 模版引用

通过ref标识来获取到真实的dom对象或者组件实例对象

## provide和inject

顶层组件向任意底层组件传递数据和方法，实现跨层组件通讯。

> 现在的前端都是按照组件的形式来进行规范和开发的，当有a->b->c，这三层组件相互依赖的时候，其中a是顶层组件，c是最底层组件。

- 顶层组件通过provide函数提供数据
- 底层组件通过inject函数获取数据

前端的数据约束规定：谁的数据谁来进行修改。

所以如果想修改父类的值，那么可以把父类的方法用上述的同样的方式给传递到底层组件中；

疑问：这里的底层组件就必须是最底层吗？中间层不能获取到顶层的数据吗？或者如何获取。

> 这个方式只适合顶层和底层的关系才能传递数据

## Pinia

是VUE的一个状态库，用来共享组件之间的状态或者数据

### storeToRefs

这个函数可以让引用的store里面的变量变成响应式数据

## 项目初始化和git管理

通过init等命令来进行初始化

## 别名路径联想配置

- 根目录添加jsconfig.json配置项

